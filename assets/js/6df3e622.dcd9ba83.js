"use strict";(self.webpackChunkpush_website=self.webpackChunkpush_website||[]).push([[10894],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return y}});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=r.createContext({}),c=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=c(e.components);return r.createElement(p.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),h=c(n),u=i,y=h["".concat(p,".").concat(u)]||h[u]||d[u]||a;return n?r.createElement(y,o(o({ref:t},l),{},{components:n})):r.createElement(y,o({ref:t},l))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[h]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<a;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},57831:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return p},default:function(){return y},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return h}});var r=n(87462),i=n(63366),a=(n(67294),n(3905)),o=["components"],s={id:"docs-chat-encryption-version-in-push-chat",title:"Encryption Version in Push Chat",hide_title:!0,slug:"./encryption-version-in-push-chat",displayed_sidebar:"pushChatSidebar",sidebar_position:2,image:"/assets/docs/previews/docs_chat--encryption_version_in_push_chat.png"},p="Encryption in Push Chat",c={unversionedId:"chat/concepts/docs-chat-encryption-version-in-push-chat",id:"chat/concepts/docs-chat-encryption-version-in-push-chat",title:"Encryption Version in Push Chat",description:"Each Push profile or user of Push Chat has a PGP key that is created locally and stored encrypted on Push nodes. Push SDK during initialization automatically decrypts your key by asking you to sign a nonce which is used to derive the signature that is applied to encrypt or decrypt your PGP keys.",source:"@site/docs/chat/05-concepts/02-Concepts-Encryption-Version.mdx",sourceDirName:"chat/05-concepts",slug:"/chat/concepts/encryption-version-in-push-chat",permalink:"/docs/chat/concepts/encryption-version-in-push-chat",draft:!1,editUrl:"https://github.com/ethereum-push-notification-service/push-website/blob/main/docs/chat/05-concepts/02-Concepts-Encryption-Version.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"docs-chat-encryption-version-in-push-chat",title:"Encryption Version in Push Chat",hide_title:!0,slug:"./encryption-version-in-push-chat",displayed_sidebar:"pushChatSidebar",sidebar_position:2,image:"/assets/docs/previews/docs_chat--encryption_version_in_push_chat.png"},sidebar:"pushChatSidebar",previous:{title:"Push Chat Architecture",permalink:"/docs/chat/concepts/push-chat-architecture"}},l={},h=[{value:"Recommended encryption version for Push Profile",id:"recommended-encryption-version-for-push-profile",level:2},{value:"Supported Encryption Versions for Push Profile",id:"supported-encryption-versions-for-push-profile",level:2},{value:"PGP_V1",id:"pgp_v1",level:3},{value:"PGP_V2",id:"pgp_v2",level:3},{value:"PGP_V3",id:"pgp_v3",level:3},{value:"NFTPGP_V1",id:"nftpgp_v1",level:3}],d={toc:h},u="wrapper";function y(e){var t=e.components,n=(0,i.Z)(e,o);return(0,a.kt)(u,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"encryption-in-push-chat"},"Encryption in Push Chat"),(0,a.kt)("p",null,"Each Push profile or user of Push Chat has a PGP key that is created locally and stored encrypted on Push nodes. Push SDK during initialization automatically decrypts your key by asking you to sign a nonce which is used to derive the signature that is applied to encrypt or decrypt your PGP keys."),(0,a.kt)("p",null,"Once the PGP keys are obtained locally, they are then used (in your local sandbox) to encrypt / decrypt messages, chat requests and anything that you do within Push network."),(0,a.kt)("p",null,"Since your wallet acts only as a way to encrypt or decrypt your PGP keys and your keys encryption are not reliant or tied directly to a particular algorithm. This paves the way for cross-chain or even multi-chain communication as dynamic versions compatible with different chains or new standards can be applied."),(0,a.kt)("p",null,"This is possible because Push maintains your PGP keys encryption version and thus is able to decrypt them using the correct standards."),(0,a.kt)("h2",{id:"recommended-encryption-version-for-push-profile"},"Recommended encryption version for Push Profile"),(0,a.kt)("p",null,"Current recommended encryption version for Push Profile is ",(0,a.kt)("inlineCode",{parentName:"p"},"PGP_V3")," and for Push NFT profiles is ",(0,a.kt)("inlineCode",{parentName:"p"},"NFTPGP_V1"),"."),(0,a.kt)("h2",{id:"supported-encryption-versions-for-push-profile"},"Supported Encryption Versions for Push Profile"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Encryption Version"),(0,a.kt)("th",{parentName:"tr",align:null},"Remarks"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("em",{parentName:"td"},(0,a.kt)("inlineCode",{parentName:"em"},"PGP_V1"))),(0,a.kt)("td",{parentName:"tr",align:null},"Uses ",(0,a.kt)("inlineCode",{parentName:"td"},"x25519-xsalsa20-poly1305")," algorithm")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("em",{parentName:"td"},(0,a.kt)("inlineCode",{parentName:"em"},"PGP_V2"))),(0,a.kt)("td",{parentName:"tr",align:null},"Uses ",(0,a.kt)("inlineCode",{parentName:"td"},"aes256GcmHkdfSha256")," algorithm with ",(0,a.kt)("inlineCode",{parentName:"td"},"EIP712")," type signatures")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("em",{parentName:"td"},(0,a.kt)("inlineCode",{parentName:"em"},"PGP_V3"))),(0,a.kt)("td",{parentName:"tr",align:null},"Uses ",(0,a.kt)("inlineCode",{parentName:"td"},"aes256GcmHkdfSha256")," algorithm with ",(0,a.kt)("inlineCode",{parentName:"td"},"EIP191")," type signatures")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("em",{parentName:"td"},(0,a.kt)("inlineCode",{parentName:"em"},"NFTPGP_V1"))),(0,a.kt)("td",{parentName:"tr",align:null},"Uses ",(0,a.kt)("inlineCode",{parentName:"td"},"aes256GcmHkdfSha256")," algorithm with ",(0,a.kt)("inlineCode",{parentName:"td"},"EIP191")," type signatures and client enabled overriding ",(0,a.kt)("inlineCode",{parentName:"td"},"secret"))))),(0,a.kt)("h3",{id:"pgp_v1"},"PGP_V1"),(0,a.kt)("p",null,"This encryption version represents the initial implementation for securing Push Profiles. It relies on Metamask's legacy API functions, namely ",(0,a.kt)("a",{parentName:"p",href:"https://docs.metamask.io/wallet/reference/eth_getencryptionpublickey/"},"eth_getEncryptionPublicKey")," and ",(0,a.kt)("a",{parentName:"p",href:"https://docs.metamask.io/wallet/reference/eth_decrypt/"},"eth_decrypt"),", for the encryption and decryption of PGP keys. It's important to note that these functions have been deprecated and are not supported by other providers. Consequently, we strongly recommend against using this method for encryption."),(0,a.kt)("p",null,"For more details on the deprecation of these functions, please refer to the official announcement ",(0,a.kt)("a",{parentName:"p",href:"https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686"},"here"),"."),(0,a.kt)("h3",{id:"pgp_v2"},"PGP_V2"),(0,a.kt)("p",null,"This encryption version utilizes the ",(0,a.kt)("inlineCode",{parentName:"p"},"aes256Gcm")," algorithm for encrypting PGP keys. In this scheme, a random nonce, salt, and an ",(0,a.kt)("inlineCode",{parentName:"p"},"EIP-712"),"-based signature are used to create the encryption key. The nonce, salt, and encrypted private keys are securely stored on Push Nodes. When combined with the user's signature, these components enable the decryption of the PGP keys."),(0,a.kt)("h3",{id:"pgp_v3"},"PGP_V3"),(0,a.kt)("p",null,"This encryption version is the same as ",(0,a.kt)("inlineCode",{parentName:"p"},"PGP_V2"),", but it uses an ",(0,a.kt)("inlineCode",{parentName:"p"},"EIP-191"),"-based signature instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"EIP-712"),". The transition to ",(0,a.kt)("inlineCode",{parentName:"p"},"EIP-191")," signatures simplifies cross-chain compatibility and eliminates the necessity for typed data signing for straightforward messages."),(0,a.kt)("h3",{id:"nftpgp_v1"},"NFTPGP_V1"),(0,a.kt)("p",null,"This encryption version is specifically designed for securing NFT Push Profiles within the framework of NFT Chat. NFT Chats introduce a unique concept where chat history becomes tied to an NFT and is carried along with the NFT when it changes ownership between users."),(0,a.kt)("p",null,"In this encryption method, users generate a secret or password, which is subsequently used to encrypt the PGP Private key. This secret is then encrypted using the ",(0,a.kt)("inlineCode",{parentName:"p"},"PGP_V3")," encryption scheme. Consequently, there are two methods for decrypting an NFT profile:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"By providing the secret directly or decrypting the secret by signing a message, which in turn is used to decrypt the PGP Key.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"During NFT transfers, the previous owner has the option to share the secret with the new owner, granting access to the chat history. Alternatively, the new owner can choose to create a new secret, effectively resetting the chat history."))))}y.isMDXComponent=!0}}]);